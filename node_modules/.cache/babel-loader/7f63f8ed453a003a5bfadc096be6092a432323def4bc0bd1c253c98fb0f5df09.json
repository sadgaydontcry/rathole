{"ast":null,"code":"// Function to tweak image generation logic\nlet imageIncrement=0;const acceptableOverlap=(overlapArea,smallerArea)=>{if(imageIncrement>5){return overlapArea/smallerArea>0.4;}return overlapArea/smallerArea>0.1;};export const resetImageIncrement=()=>imageIncrement=0;export const parsePercentage=(value,base)=>parseInt(value)/100*base;// Function to generate a random position and size for each image\nconst generateRandomPosition=containerWidth=>{const width=Math.floor(Math.random()*20)+15+\"%\";// Random width (15% to 35%)\nconst widthPx=parsePercentage(width,containerWidth);const top=Math.floor(Math.random()*5000)+\"px\";// Random top position (allow it to extend)\nconst left=Math.floor(Math.random()*(containerWidth-widthPx))+\"px\";// Random left position within bounds\nreturn{top,left,width};};const isOverlapping=(image1,image2,containerWidth)=>{const width1=parsePercentage(image1.width,containerWidth);const height1=width1;// Assuming square images for simplicity\nconst top1=parseInt(image1.top);const left1=parseInt(image1.left);const width2=parsePercentage(image2.width,containerWidth);const height2=width2;// Assuming square images for simplicity\nconst top2=parseInt(image2.top);const left2=parseInt(image2.left);// Calculate the overlapping area\nconst overlapX=Math.max(0,Math.min(left1+width1,left2+width2)-Math.max(left1,left2));const overlapY=Math.max(0,Math.min(top1+height1,top2+height2)-Math.max(top1,top2));const overlapArea=overlapX*overlapY;// Calculate the area of the smaller image\nconst area1=width1*height1;const area2=width2*height2;const smallerArea=Math.min(area1,area2);return acceptableOverlap(overlapArea,smallerArea);};export const generateValidPosition=(existingImages,containerWidth)=>{let newImage={top:\"0%\",left:\"0%\",width:\"0%\"};let isValid=false;while(!isValid){newImage=generateRandomPosition(containerWidth);isValid=existingImages.every(existingImage=>!isOverlapping(existingImage,newImage,containerWidth));}imageIncrement++;return newImage;};// Debounce function to prevent frequent execution during resizing\nexport const debounce=(func,delay)=>{let timeoutId;return function(){for(var _len=arguments.length,args=new Array(_len),_key=0;_key<_len;_key++){args[_key]=arguments[_key];}clearTimeout(timeoutId);timeoutId=setTimeout(()=>{func.apply(null,args);},delay);};};","map":{"version":3,"names":["imageIncrement","acceptableOverlap","overlapArea","smallerArea","resetImageIncrement","parsePercentage","value","base","parseInt","generateRandomPosition","containerWidth","width","Math","floor","random","widthPx","top","left","isOverlapping","image1","image2","width1","height1","top1","left1","width2","height2","top2","left2","overlapX","max","min","overlapY","area1","area2","generateValidPosition","existingImages","newImage","isValid","every","existingImage","debounce","func","delay","timeoutId","_len","arguments","length","args","Array","_key","clearTimeout","setTimeout","apply"],"sources":["/home/ash/Documents/RATHOLE/src/components/Gallery/utils.ts"],"sourcesContent":["import { ImageStyles } from \"./interfaces\";\n\n// Function to tweak image generation logic\nlet imageIncrement = 0;\nconst acceptableOverlap = (\n    overlapArea: number,\n    smallerArea: number\n) => {\n    if (imageIncrement > 5) {\n        return overlapArea / smallerArea > 0.4;\n    }\n    return overlapArea / smallerArea > 0.1;\n}\n\nexport const resetImageIncrement = () => imageIncrement = 0;\nexport const parsePercentage = (value: string, base: number) => (parseInt(value) / 100) * base;\n\n// Function to generate a random position and size for each image\nconst generateRandomPosition = (containerWidth: number): ImageStyles => {\n    const width = Math.floor(Math.random() * 20) + 15 + \"%\"; // Random width (15% to 35%)\n    const widthPx = parsePercentage(width, containerWidth);\n\n    const top = Math.floor(Math.random() * 5000) + \"px\"; // Random top position (allow it to extend)\n    const left = Math.floor(Math.random() * (containerWidth - widthPx)) + \"px\"; // Random left position within bounds\n\n    return { top, left, width };\n};\n\nconst isOverlapping = (\n    image1: ImageStyles,\n    image2: ImageStyles,\n    containerWidth: number,\n) => {\n    const width1 = parsePercentage(image1.width, containerWidth);\n    const height1 = width1; // Assuming square images for simplicity\n    const top1 = parseInt(image1.top);\n    const left1 = parseInt(image1.left);\n\n    const width2 = parsePercentage(image2.width, containerWidth);\n    const height2 = width2; // Assuming square images for simplicity\n    const top2 = parseInt(image2.top);\n    const left2 = parseInt(image2.left);\n\n    // Calculate the overlapping area\n    const overlapX = Math.max(\n        0,\n        Math.min(left1 + width1, left2 + width2) - Math.max(left1, left2)\n    );\n    const overlapY = Math.max(\n        0,\n        Math.min(top1 + height1, top2 + height2) - Math.max(top1, top2)\n    );\n    const overlapArea = overlapX * overlapY;\n\n    // Calculate the area of the smaller image\n    const area1 = width1 * height1;\n    const area2 = width2 * height2;\n    const smallerArea = Math.min(area1, area2);\n\n    return acceptableOverlap(overlapArea, smallerArea);\n};\n\nexport const generateValidPosition = (\n    existingImages: ImageStyles[],\n    containerWidth: number,\n) => {\n    let newImage: ImageStyles = { top: \"0%\", left: \"0%\", width: \"0%\" };\n    let isValid = false;\n\n    while (!isValid) {\n        newImage = generateRandomPosition(containerWidth);\n        isValid = existingImages.every(\n            (existingImage) => !isOverlapping(existingImage, newImage, containerWidth)\n        );\n    }\n\n    imageIncrement++;\n    return newImage;\n};\n\n// Debounce function to prevent frequent execution during resizing\n export const debounce = (func: Function, delay: number) => {\n  let timeoutId: NodeJS.Timeout;\n  return (...args: any[]) => {\n    clearTimeout(timeoutId);\n    timeoutId = setTimeout(() => {\n      func.apply(null, args);\n    }, delay);\n  };\n};\n"],"mappings":"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","ignoreList":[]},"metadata":{},"sourceType":"module","externalDependencies":[]}