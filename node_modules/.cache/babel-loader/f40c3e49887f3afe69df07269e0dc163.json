{"ast":null,"code":"// Function to tweak image generation logic\nlet imageIncrement = 0;\nconst acceptableOverlap = (overlapArea, smallerArea) => {\n  if (imageIncrement > 5) {\n    return overlapArea / smallerArea > 0.4;\n  }\n  return overlapArea / smallerArea > 0.1;\n};\nexport const resetImageIncrement = () => imageIncrement = 0;\nexport const parsePercentage = (value, base) => parseInt(value) / 100 * base;\n\n// Function to generate a random position and size for each image\nconst generateRandomPosition = containerWidth => {\n  const width = Math.floor(Math.random() * 20) + 15 + \"%\"; // Random width (15% to 35%)\n  const widthPx = parsePercentage(width, containerWidth);\n  const top = Math.floor(Math.random() * 5000) + \"px\"; // Random top position (allow it to extend)\n  const left = Math.floor(Math.random() * (containerWidth - widthPx)) + \"px\"; // Random left position within bounds\n\n  return {\n    top,\n    left,\n    width\n  };\n};\nconst isOverlapping = (image1, image2, containerWidth) => {\n  const width1 = parsePercentage(image1.width, containerWidth);\n  const height1 = width1; // Assuming square images for simplicity\n  const top1 = parseInt(image1.top);\n  const left1 = parseInt(image1.left);\n  const width2 = parsePercentage(image2.width, containerWidth);\n  const height2 = width2; // Assuming square images for simplicity\n  const top2 = parseInt(image2.top);\n  const left2 = parseInt(image2.left);\n\n  // Calculate the overlapping area\n  const overlapX = Math.max(0, Math.min(left1 + width1, left2 + width2) - Math.max(left1, left2));\n  const overlapY = Math.max(0, Math.min(top1 + height1, top2 + height2) - Math.max(top1, top2));\n  const overlapArea = overlapX * overlapY;\n\n  // Calculate the area of the smaller image\n  const area1 = width1 * height1;\n  const area2 = width2 * height2;\n  const smallerArea = Math.min(area1, area2);\n  return acceptableOverlap(overlapArea, smallerArea);\n};\nexport const generateValidPosition = (existingImages, containerWidth) => {\n  let newImage = {\n    top: \"0%\",\n    left: \"0%\",\n    width: \"0%\"\n  };\n  let isValid = false;\n  while (!isValid) {\n    newImage = generateRandomPosition(containerWidth);\n    isValid = existingImages.every(existingImage => !isOverlapping(existingImage, newImage, containerWidth));\n  }\n  imageIncrement++;\n  return newImage;\n};\n\n// Debounce function to prevent frequent execution during resizing\nexport const debounce = (func, delay) => {\n  let timeoutId;\n  return (...args) => {\n    clearTimeout(timeoutId);\n    timeoutId = setTimeout(() => {\n      func.apply(null, args);\n    }, delay);\n  };\n};","map":{"version":3,"names":["imageIncrement","acceptableOverlap","overlapArea","smallerArea","resetImageIncrement","parsePercentage","value","base","parseInt","generateRandomPosition","containerWidth","width","Math","floor","random","widthPx","top","left","isOverlapping","image1","image2","width1","height1","top1","left1","width2","height2","top2","left2","overlapX","max","min","overlapY","area1","area2","generateValidPosition","existingImages","newImage","isValid","every","existingImage","debounce","func","delay","timeoutId","args","clearTimeout","setTimeout","apply"],"sources":["/home/ash/Documents/RATHOLE/src/components/Gallery/utils.ts"],"sourcesContent":["import { ImageStyles } from \"./interfaces\";\n\n// Function to tweak image generation logic\nlet imageIncrement = 0;\nconst acceptableOverlap = (\n    overlapArea: number,\n    smallerArea: number\n) => {\n    if (imageIncrement > 5) {\n        return overlapArea / smallerArea > 0.4;\n    }\n    return overlapArea / smallerArea > 0.1;\n}\n\nexport const resetImageIncrement = () => imageIncrement = 0;\nexport const parsePercentage = (value: string, base: number) => (parseInt(value) / 100) * base;\n\n// Function to generate a random position and size for each image\nconst generateRandomPosition = (containerWidth: number): ImageStyles => {\n    const width = Math.floor(Math.random() * 20) + 15 + \"%\"; // Random width (15% to 35%)\n    const widthPx = parsePercentage(width, containerWidth);\n\n    const top = Math.floor(Math.random() * 5000) + \"px\"; // Random top position (allow it to extend)\n    const left = Math.floor(Math.random() * (containerWidth - widthPx)) + \"px\"; // Random left position within bounds\n\n    return { top, left, width };\n};\n\nconst isOverlapping = (\n    image1: ImageStyles,\n    image2: ImageStyles,\n    containerWidth: number,\n) => {\n    const width1 = parsePercentage(image1.width, containerWidth);\n    const height1 = width1; // Assuming square images for simplicity\n    const top1 = parseInt(image1.top);\n    const left1 = parseInt(image1.left);\n\n    const width2 = parsePercentage(image2.width, containerWidth);\n    const height2 = width2; // Assuming square images for simplicity\n    const top2 = parseInt(image2.top);\n    const left2 = parseInt(image2.left);\n\n    // Calculate the overlapping area\n    const overlapX = Math.max(\n        0,\n        Math.min(left1 + width1, left2 + width2) - Math.max(left1, left2)\n    );\n    const overlapY = Math.max(\n        0,\n        Math.min(top1 + height1, top2 + height2) - Math.max(top1, top2)\n    );\n    const overlapArea = overlapX * overlapY;\n\n    // Calculate the area of the smaller image\n    const area1 = width1 * height1;\n    const area2 = width2 * height2;\n    const smallerArea = Math.min(area1, area2);\n\n    return acceptableOverlap(overlapArea, smallerArea);\n};\n\nexport const generateValidPosition = (\n    existingImages: ImageStyles[],\n    containerWidth: number,\n) => {\n    let newImage: ImageStyles = { top: \"0%\", left: \"0%\", width: \"0%\" };\n    let isValid = false;\n\n    while (!isValid) {\n        newImage = generateRandomPosition(containerWidth);\n        isValid = existingImages.every(\n            (existingImage) => !isOverlapping(existingImage, newImage, containerWidth)\n        );\n    }\n\n    imageIncrement++;\n    return newImage;\n};\n\n// Debounce function to prevent frequent execution during resizing\n export const debounce = (func: Function, delay: number) => {\n  let timeoutId: NodeJS.Timeout;\n  return (...args: any[]) => {\n    clearTimeout(timeoutId);\n    timeoutId = setTimeout(() => {\n      func.apply(null, args);\n    }, delay);\n  };\n};\n"],"mappings":"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","ignoreList":[]},"metadata":{},"sourceType":"module"}